# FastAuth

A comprehensive authentication library for FastAPI applications with JWT-based authentication, role-based authorization, and SQLModel integration. Featuring a modular architecture for better maintainability and extensibility.

## Features

- **OAuth2 and JWT authentication** built-in
- **Role-based authorization** system
- **Cookie-based authentication** option
- **Token refresh mechanism** for extended sessions
- **SQLModel integration** for easy database operations
- **CLI utilities** for database initialization and management
- **Ready-to-use authentication routes** with minimal setup
- **Password hashing** with bcrypt
- **Modular architecture** for better code organization and extensibility

## Installation

```bash
pip install fastauth_iq
```

Or install from source:

```bash
git clone https://github.com/hu55ain3laa/fastauth.git
cd fastauth
pip install -e .
```

## Quick Start

### 1. Create a User Model

FastAuth works with SQLModel's user model. You can use the built-in User model or create your own:

```python
from sqlmodel import SQLModel, Field

class User(SQLModel, table=True):
    id: int = Field(primary_key=True)
    username: str = Field(unique=True)
    email: str = Field(unique=True)
    hashed_password: str
    disabled: bool = Field(default=False)
```

### 2. Initialize FastAuth in Your Application

```python
from fastapi import FastAPI, Depends
from sqlmodel import create_engine, Session, SQLModel

from fastauth import FastAuth, User

# Create FastAPI app
app = FastAPI()

# Setup database
engine = create_engine("sqlite:///./app.db")

# Session dependency
def get_session():
    with Session(engine) as session:
        yield session

# Initialize FastAuth with your configuration
auth = FastAuth(
    secret_key="your-secure-secret-key",  # Use strong secret in production
    algorithm="HS256",
    user_model=User,
    engine=engine,
    use_cookie=True,  # Enable cookie-based auth (optional)
    token_url="/token",
    access_token_expires_in=30,  # minutes
    refresh_token_expires_in=7   # days
)

# Initialize database (choose ONE of these approaches):
# Option 1: Using the CLI tool before starting the application (new in v0.3.0)
#   fastauth app.py                   # Auto-detect settings from your app file
#   # Or use explicit parameters
#   fastauth --db-url="sqlite:///./app.db" --secret-key="your-secret-key"
#
# Option 2: Initializing during application startup
INIT_DB_ON_STARTUP = True  # Set to False to disable

@app.on_event("startup")
def on_startup():
    if INIT_DB_ON_STARTUP:
        auth.initialize_db(
            create_tables=True,         # Create database tables
            init_roles=True,            # Initialize standard roles
            create_admin=True,          # Create superadmin if needed
            admin_username="superadmin", # Default username
            admin_password="admin123"    # Default password
        )

# Add all authentication routes automatically
auth_router = auth.get_auth_router(get_session)
app.include_router(auth_router, tags=["authentication"])

# Add role management routes (new in v0.2.2)
role_router = auth.get_role_router()
app.include_router(role_router, tags=["roles"])
```

### 3. Protect Your Routes

```python
# Require authentication only
@app.get("/protected")
def protected_route(current_user = Depends(auth.get_current_active_user_dependency())):
    return {"message": f"Hello, {current_user.username}!"}

# Require specific roles (any of the listed roles)
@app.get("/admin-or-moderator")
def admin_or_mod_route(current_user = Depends(auth.require_roles(["admin", "moderator"]))):
    return {"message": f"Hello privileged user, {current_user.username}!"}

# Require all listed roles
@app.get("/admin-and-verified")
def admin_and_verified_route(current_user = Depends(auth.require_all_roles(["admin", "verified"]))):
    return {"message": f"Hello admin with verification, {current_user.username}!"}

# Shortcut for admin-only routes
@app.get("/admin-only")
def admin_only_route(current_user = Depends(auth.is_admin())):
    return {"message": f"Hello admin, {current_user.username}!"}
```

## Available Authentication Endpoints

The `get_auth_router()` method automatically adds these endpoints to your application:

- **POST /token** - Get access and refresh tokens with username/password
- **POST /token/refresh** - Get a new access token using a refresh token
- **POST /users** - Register a new user
- **GET /users/me** - Get the current authenticated user's information

## Role Management Endpoints

The `get_role_router()` method adds these role management endpoints:

- **POST /roles/** - Create a new role (admin only)
- **GET /roles/** - Get all roles 
- **GET /roles/{role_id}** - Get a role by ID
- **PUT /roles/{role_id}** - Update a role (admin only)
- **DELETE /roles/{role_id}** - Delete a role (admin only)
- **POST /roles/assign/{user_id}/{role_id}** - Assign a role to a user (admin only)
- **DELETE /roles/assign/{user_id}/{role_id}** - Remove a role from a user (admin only)
- **GET /roles/user/{user_id}** - Get all roles for a user

## Customization Options

### Cookie-Based Authentication

Enable cookie-based authentication by setting `use_cookie=True`:

```python
auth = FastAuth(
    # ... other parameters
    use_cookie=True
)
```

### Custom Token Expiration

Set custom expiration times for tokens:

```python
auth = FastAuth(
    # ... other parameters
    access_token_expires_in=60,  # 60 minutes
    refresh_token_expires_in=30  # 30 days
)
```

### Advanced Usage: Custom Authentication Routes

You can create your own authentication routes instead of using the built-in router:

```python
@app.post("/custom-login")
async def custom_login(
    username: str, 
    password: str, 
    session: Session = Depends(get_session)
):
    user = auth.authenticate_user(username, password)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    access_token = auth.create_access_token(data={"sub": user.username})
    return {"access_token": access_token, "token_type": "bearer"}
```

## Security Best Practices

1. **Always use HTTPS** in production
2. **Use a strong secret key** and keep it secure
3. **Set appropriate token expiration times**
4. **Enable httpOnly and secure flags** for cookies
5. **Consider implementing rate limiting** for authentication endpoints

## License

MIT

## Database Initialization

FastAuth offers two approaches for database initialization: via command-line tool or programmatically during application startup. Choose the approach that best fits your workflow.

### Option 1: Initialization via CLI (new in v0.3.0)

Using the command-line tool separates database setup from application startup, which is ideal for production environments.

### Using the CLI Tool

```bash
# Just provide your app file - FastAuth will extract settings automatically
fastauth example.py

# Or use the traditional approach
fastauth --db-url="sqlite:///./app.db" --secret-key="your-secret-key"

# Customize the superadmin credentials
fastauth example.py --username="admin" --password="secure_password"

# Run specific initialization steps
fastauth example.py --init-db --init-roles --create-superadmin
```

The CLI tool will prompt for credentials if not provided, with defaults:
- Username: `superadmin`
- Password: `admin123`

### Setting up your Application File for Auto-Detection

When using the `fastauth example.py` syntax, FastAuth auto-detects database URL and secret key settings from your file. Use these formats for automatic detection:

```python
# Database URL - any of these formats will be detected
DATABASE_URL = "sqlite:///./app.db"
database_url = "sqlite:///./app.db"
db_url = "sqlite:///./app.db"
engine = create_engine("sqlite:///./app.db")

# Secret Key - any of these formats will be detected
SECRET_KEY = "your-secret-key-here"
secret_key = "your-secret-key-here"
```

These patterns are case-sensitive. If FastAuth cannot detect your settings, you can still provide them with the `--db-url` and `--secret-key` flags.

### Standard Roles

The initialization creates these standard roles:
- `superadmin`: Super administrator with all privileges
- `admin`: Administrator with management privileges
- `moderator`: User with content moderation privileges 
- `premium`: Premium tier user
- `verified`: Verified user
- `user`: Standard user with basic privileges

### Option 2: Programmatic Initialization

You can also initialize the database programmatically during application startup, which is simpler for development environments:

```python
# Initialize during application startup
@app.on_event("startup")
def on_startup():
    auth.initialize_db(
        create_tables=True,         # Create database tables
        init_roles=True,            # Initialize standard roles
        create_admin=True,          # Create superadmin if needed
        admin_username="superadmin", # Default username
        admin_password="admin123"    # Default password
    )
```

You can also create a superadmin user programmatically at any time:

```python
# Create a superadmin user with default credentials
auth.create_superadmin()

# Or with custom credentials
auth.create_superadmin(username="admin", password="secure_password")
```

## Role-Based Authorization

FastAuth includes a robust role-based authorization system:

### Creating and Managing Roles

```python
# Get the role manager through a dependency
@app.post("/custom-role")
async def create_custom_role(
    role_data: RoleCreate,
    role_manager = Depends(auth.get_role_manager())
):
    return role_manager.create_role(role_data)
```

### Assigning Roles to Users

```python
# Assign an admin role to a user
@app.post("/make-admin/{user_id}")
async def make_admin(
    user_id: int,
    role_manager = Depends(auth.get_role_manager())
):
    # Get or create the admin role
    admin_role = role_manager.get_role(role_name="admin")
    if not admin_role:
        admin_role = role_manager.create_role(RoleCreate(name="admin", description="Administrator"))
    
    # Assign the role
    role_manager.assign_role_to_user(user_id, admin_role.id)
    return {"message": "User is now an admin"}
```

## Modular Architecture

With version 0.3.0, FastAuth continues to improve its modular architecture for better maintainability, testability, and extensibility. The code is organized into specialized modules:

```
fastauth/
├── core/          # Core FastAuth class and OAuth2 implementation
├── security/      # Password management and token handling
├── models/        # User, role and token data models
│   ├── user.py    # User models with role relationships
│   ├── role.py    # Role models for authorization
│   └── tokens.py  # Token data models
├── routers/       # Route handlers for auth and roles
├── dependencies/  # FastAPI dependencies for auth and roles
└── utils/         # Utility functions and helpers
```

This modular structure makes it easier to:
- Understand and modify specific parts of the library
- Write targeted tests for each component
- Extend functionality with new features
- Reuse components in other projects

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.
